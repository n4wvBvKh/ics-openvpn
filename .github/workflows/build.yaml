# The name of our workflow
name: Build with XOR Patch

permissions:
  contents: read

on: 
  push:
  pull_request:
  workflow_dispatch:

jobs:
  build:
    strategy:
      fail-fast: false
      matrix:
        target: [UiOvpn2]
    name: "Release ${{ matrix.target }}"
    runs-on: ubuntu-latest
    steps:
      - name: Use debug signing
        run: mkdir -p ~/.gradle && echo -e "icsopenvpnDebugSign=true\norg.gradle.jvmargs=-Xmx2048M" > ~/.gradle/gradle.properties
      
      - name: Checkout the code
        uses: actions/checkout@v4
        with:
          submodules: true
          
      - name: Copy and Apply XOR patches
        run: |
          cp -r tunnelblick-patches/* main/src/main/cpp/openvpn/
          cd main/src/main/cpp/openvpn
          
          echo "=== 1. Apply configs (B, C, D) ==="
          patch -p1 --forward < 03-tunnelblick-openvpn_xorpatch-b.diff || true
          patch -p1 --forward < 04-tunnelblick-openvpn_xorpatch-c.diff || true
          patch -p1 --forward < 05-tunnelblick-openvpn_xorpatch-d.diff || true
          
          echo "=== 2. Python Surgical Injection ==="
          cat << 'EOF' > inject_xor.py
          import re
          
          with open('src/openvpn/forward.c', 'r') as f:
              fc = f.read()
          fc = re.sub(r"(status\s*=\s*link_socket_read\s*\(\s*c->c2\.link_socket,\s*&c->c2\.buf,\s*&c->c2\.from)\s*\);", r"\1, c->options.ce.xormethod, c->options.ce.xormask, c->options.ce.xormasklen);", fc)
          fc = re.sub(r"(size\s*=\s*link_socket_write\s*\(\s*c->c2\.link_socket,\s*&c->c2\.to_link,\s*to_addr)\s*\);", r"\1, c->options.ce.xormethod, c->options.ce.xormask, c->options.ce.xormasklen);", fc)
          with open('src/openvpn/forward.c', 'w') as f:
              f.write(fc)
          
          with open('src/openvpn/socket.h', 'r') as f:
              sh = f.read()
          
          # 提前注入函数声明，防止 Clang 报错
          decl = "\nint buffer_mask(struct buffer *buf, const char *mask, int xormasklen);\nint buffer_xorptrpos(struct buffer *buf);\nint buffer_reverse(struct buffer *buf);\n"
          sh = decl + sh
          
          parts = sh.split('link_socket_read(struct link_socket')
          if len(parts) > 1:
              body = parts[1]
              # 修复函数签名
              body = re.sub(r'(\*sock,\s*struct buffer \*buf,\s*struct link_socket_actual \*from)\s*\)', r"\1, int xormethod, const char *xormask, int xormasklen)", body, count=1)
              # 剥离局部 res 变量并提升为全局作用域
              body = re.sub(r'\{\s*int\s+res;', '{', body)
              body = body.replace('{', '{\n    int res;', 1)
              body = re.sub(r'return\s+res;', '/* return res; */', body)
              body = re.sub(r'return\s+(link_socket_read_tcp[^;]+;)', r'res = \1', body)
              # 植入异或逻辑
              inj = "switch(xormethod) { case 0: break; case 1: buffer_mask(buf,xormask,xormasklen); break; case 2: buffer_xorptrpos(buf); break; case 3: buffer_reverse(buf); break; case 4: buffer_mask(buf,xormask,xormasklen); buffer_xorptrpos(buf); buffer_reverse(buf); buffer_xorptrpos(buf); break; default: ASSERT(0); return -1; } return res; }"
              body = re.sub(r'(else\s*\{\s*ASSERT\s*\(\s*0\s*\)\s*;\s*return\s+-1;\s*(?:/\*.*?\*/\s*)?\})\s*\}', r'\1' + inj, body, count=1)
              parts[1] = body
              sh = 'link_socket_read(struct link_socket'.join(parts)
          
          parts = sh.split('link_socket_write(struct link_socket')
          if len(parts) > 1:
              body = parts[1]
              body = re.sub(r'(\*sock,\s*struct buffer \*buf,\s*struct link_socket_actual \*to)\s*\)', r"\1, int xormethod, const char *xormask, int xormasklen)", body, count=1)
              inj_w = "{ switch(xormethod) { case 0: break; case 1: buffer_mask(buf,xormask,xormasklen); break; case 2: buffer_xorptrpos(buf); break; case 3: buffer_reverse(buf); break; case 4: buffer_xorptrpos(buf); buffer_reverse(buf); buffer_xorptrpos(buf); buffer_mask(buf,xormask,xormasklen); break; default: ASSERT(0); return -1; } "
              body = body.replace('{', inj_w, 1)
              parts[1] = body
              sh = 'link_socket_write(struct link_socket'.join(parts)
          
          with open('src/openvpn/socket.h', 'w') as f:
              f.write(sh)
          EOF
          python3 inject_xor.py

      - name: set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: 'zulu'
          java-version: 17
          cache: 'gradle'
          
      - name: Setup Android SDK
        uses: android-actions/setup-android@v3
        
      - name: Build the app
        run: ./gradlew assemble${{ matrix.target }}Release

      - name: Archive apk artifact
        uses: actions/upload-artifact@v4
        with:
          name: build-${{matrix.target}}-release-apk
          path: main/build/outputs/apk/**/*universal*.apk
