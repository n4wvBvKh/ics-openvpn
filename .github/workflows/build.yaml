# The name of our workflow
name: Build with XOR Patch

permissions:
  contents: read

on: 
  push:
  pull_request:
  workflow_dispatch:

jobs:
  build:
    strategy:
      fail-fast: false
      matrix:
        target: [UiOvpn2]
    name: "Release ${{ matrix.target }}"
    runs-on: ubuntu-latest
    steps:
      - name: Use debug signing
        run: mkdir -p ~/.gradle && echo -e "icsopenvpnDebugSign=true\norg.gradle.jvmargs=-Xmx2048M" > ~/.gradle/gradle.properties
      
      - name: Checkout the code
        uses: actions/checkout@v4
        with:
          submodules: true
          
      - name: Copy and Apply XOR patches
        run: |
          cp -r tunnelblick-patches/* main/src/main/cpp/openvpn/
          cd main/src/main/cpp/openvpn
          
          echo "=== 1. 应用基础参数补丁 (B, C, D) ==="
          patch -p1 --forward < 03-tunnelblick-openvpn_xorpatch-b.diff || true
          patch -p1 --forward < 04-tunnelblick-openvpn_xorpatch-c.diff || true
          patch -p1 --forward < 05-tunnelblick-openvpn_xorpatch-d.diff || true
          
          echo "=== 2. Python 高级包装注入 (Wrapper Method) ==="
          cat << 'EOF' > inject_xor.py
          import re
          
          # 1) 替换调用端的传参 (forward.c)
          with open('src/openvpn/forward.c', 'r') as f:
              fc = f.read()
          
          fc = re.sub(r"(status\s*=\s*link_socket_read\s*\(\s*c->c2\.link_socket,\s*&c->c2\.buf,\s*&c->c2\.from)\s*\);", r"\1, c->options.ce.xormethod, c->options.ce.xormask, c->options.ce.xormasklen);", fc)
          fc = re.sub(r"(size\s*=\s*link_socket_write\s*\(\s*c->c2\.link_socket,\s*&c->c2\.to_link,\s*to_addr)\s*\);", r"\1, c->options.ce.xormethod, c->options.ce.xormask, c->options.ce.xormasklen);", fc)
          
          with open('src/openvpn/forward.c', 'w') as f:
              f.write(fc)
          
          # 2) 包装底层函数 (socket.h)
          with open('src/openvpn/socket.h', 'r') as f:
              sh = f.read()
          
          # 把原来的收发函数重命名为 _ORIG，完全不破坏其内部结构
          sh = re.sub(r'\blink_socket_read\s*\(\s*struct link_socket', 'link_socket_read_ORIG(struct link_socket', sh)
          sh = re.sub(r'\blink_socket_write\s*\(\s*struct link_socket', 'link_socket_write_ORIG(struct link_socket', sh)
          
          # 制作全新的混淆外壳函数
          wrappers = """
          void buffer_mask(struct buffer *buf, const char *mask, int xormasklen);
          void buffer_xorptrpos(struct buffer *buf);
          void buffer_reverse(struct buffer *buf);
          
          static inline int
          link_socket_read(struct link_socket *sock, struct buffer *buf, struct link_socket_actual *from, int xormethod, const char *xormask, int xormasklen)
          {
              int res = link_socket_read_ORIG(sock, buf, from);
              switch(xormethod) {
                  case 0: break;
                  case 1: buffer_mask(buf,xormask,xormasklen); break;
                  case 2: buffer_xorptrpos(buf); break;
                  case 3: buffer_reverse(buf); break;
                  case 4: buffer_mask(buf,xormask,xormasklen); buffer_xorptrpos(buf); buffer_reverse(buf); buffer_xorptrpos(buf); break;
              }
              return res;
          }
          
          static inline int
          link_socket_write(struct link_socket *sock, struct buffer *buf, struct link_socket_actual *to, int xormethod, const char *xormask, int xormasklen)
          {
              switch(xormethod) {
                  case 0: break;
                  case 1: buffer_mask(buf,xormask,xormasklen); break;
                  case 2: buffer_xorptrpos(buf); break;
                  case 3: buffer_reverse(buf); break;
                  case 4: buffer_xorptrpos(buf); buffer_reverse(buf); buffer_xorptrpos(buf); buffer_mask(buf,xormask,xormasklen); break;
              }
              return link_socket_write_ORIG(sock, buf, to);
          }
          """
          
          # 将外壳函数安全地放到文件最底部
          last_endif = sh.rfind('#endif')
          if last_endif != -1:
              sh = sh[:last_endif] + wrappers + "\\n" + sh[last_endif:]
          else:
              sh += wrappers
          
          with open('src/openvpn/socket.h', 'w') as f:
              f.write(sh)
          EOF
          python3 inject_xor.py

      - name: set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: 'zulu'
          java-version: 17
          cache: 'gradle'
          
      - name: Setup Android SDK
        uses: android-actions/setup-android@v3
        
      - name: Build the app
        run: ./gradlew assemble${{ matrix.target }}Release --stacktrace

      - name: Archive apk artifact
        uses: actions/upload-artifact@v4
        with:
          name: build-${{matrix.target}}-release-apk
          path: main/build/outputs/apk/**/*universal*.apk
